/*@@
   @file    AliasedFunctions.c
   @author  Automatically generated by CreateFunctionBindings.pl
   @desc
            Prototypes for the aliased functions.
   @enddesc
 @@*/


#include <stdlib.h>
#include <string.h>

#include "cctk_Flesh.h"
#include "cctk_WarnLevel.h"
#include "cctk_FortranString.h"

/*
 * The function pointers to be set
 */

static CCTK_INT (*Accelerator_NotifyDataModified_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device) = NULL;
static CCTK_INT (*Accelerator_NotifyDataModified_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Accelerator_NotifyDataModified (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device);
CCTK_INT Accelerator_NotifyDataModified (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device)
{
  CCTK_INT retval;

  if (!Accelerator_NotifyDataModified_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_NotifyDataModified has not been provided by any active thorn.");
  }

  retval = (*Accelerator_NotifyDataModified_C_Wrapper)(cctkGH , variables , tls , nvariables , on_device);
  return (retval);
}

CCTK_INT CCTK_FCALL accelerator_notifydatamodified_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device);
CCTK_INT CCTK_FCALL accelerator_notifydatamodified_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device)
{
  CCTK_INT retval;

  if (!Accelerator_NotifyDataModified_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Accelerator_NotifyDataModified has not been provided by any active thorn.");
  }

  retval = (*Accelerator_NotifyDataModified_F_Wrapper)(cctkGH , variables , tls , nvariables , on_device);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedAccelerator_NotifyDataModified(void);
CCTK_INT IsAliasedAccelerator_NotifyDataModified(void)
{
  return (Accelerator_NotifyDataModified_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasAccelerator_NotifyDataModified_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device));
CCTK_INT AliasAccelerator_NotifyDataModified_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT nvariables ,
 const CCTK_INT on_device))
{
  CCTK_INT aliased = Accelerator_NotifyDataModified_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_NotifyDataModified_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasAccelerator_NotifyDataModified_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device));
CCTK_INT AliasAccelerator_NotifyDataModified_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* variables ,
 const CCTK_INT* tls ,
 const CCTK_INT* nvariables ,
 const CCTK_INT* on_device))
{
  CCTK_INT aliased = Accelerator_NotifyDataModified_C_Wrapper != NULL;
  if (!aliased)
  {
    Accelerator_NotifyDataModified_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_RegisterPhysicalBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_RegisterPhysicalBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_RegisterPhysicalBC (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_RegisterPhysicalBC (const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_RegisterPhysicalBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_RegisterPhysicalBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_RegisterPhysicalBC_C_Wrapper)(GH , function_pointer , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL boundary_registerphysicalbc_ (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL boundary_registerphysicalbc_ (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_RegisterPhysicalBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_RegisterPhysicalBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_RegisterPhysicalBC_F_Wrapper)(GH , function_pointer , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_RegisterPhysicalBC(void);
CCTK_INT IsAliasedBoundary_RegisterPhysicalBC(void)
{
  return (Boundary_RegisterPhysicalBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_RegisterPhysicalBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_RegisterPhysicalBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_RegisterPhysicalBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_RegisterPhysicalBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_RegisterPhysicalBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_RegisterPhysicalBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_INT (*const function_pointer)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* num_vars ,
 const CCTK_INT* var_indices ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_widths ,
 const CCTK_INT* table_handles) ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_RegisterPhysicalBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_RegisterPhysicalBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectGroupForBC_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectGroupForBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectGroupForBC (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name);
CCTK_INT Boundary_SelectGroupForBC (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectGroupForBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBC_C_Wrapper)(cctkGH , faces , boundary_width , table_handle , group_name , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL boundary_selectgroupforbc_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL boundary_selectgroupforbc_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Boundary_SelectGroupForBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBC_F_Wrapper)(cctkGH , faces , boundary_width , table_handle , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectGroupForBC(void);
CCTK_INT IsAliasedBoundary_SelectGroupForBC(void)
{
  return (Boundary_SelectGroupForBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectGroupForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectGroupForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING group_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectGroupForBCI_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectGroupForBCI_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectGroupForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectGroupForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectGroupForBCI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBCI_C_Wrapper)(GH , faces , boundary_width , table_handle , group_index , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL boundary_selectgroupforbci_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL boundary_selectgroupforbci_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectGroupForBCI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectGroupForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectGroupForBCI_F_Wrapper)(GH , faces , boundary_width , table_handle , group_index , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectGroupForBCI(void);
CCTK_INT IsAliasedBoundary_SelectGroupForBCI(void)
{
  return (Boundary_SelectGroupForBCI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectGroupForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT group_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBCI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectGroupForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectGroupForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* group_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectGroupForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectGroupForBCI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectVarForBC_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectVarForBC_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectVarForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name);
CCTK_INT Boundary_SelectVarForBC (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectVarForBC_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBC_C_Wrapper)(GH , faces , boundary_width , table_handle , var_name , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL boundary_selectvarforbc_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL boundary_selectvarforbc_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Boundary_SelectVarForBC_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBC has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBC_F_Wrapper)(GH , faces , boundary_width , table_handle , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectVarForBC(void);
CCTK_INT IsAliasedBoundary_SelectVarForBC(void)
{
  return (Boundary_SelectVarForBC_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectVarForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBC_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBC_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectVarForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBC_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 CCTK_STRING var_name, CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBC_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBC_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectVarForBCI_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectVarForBCI_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectVarForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectVarForBCI (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectVarForBCI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBCI_C_Wrapper)(GH , faces , boundary_width , table_handle , var_index , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL boundary_selectvarforbci_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL boundary_selectvarforbci_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectVarForBCI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectVarForBCI has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectVarForBCI_F_Wrapper)(GH , faces , boundary_width , table_handle , var_index , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectVarForBCI(void);
CCTK_INT IsAliasedBoundary_SelectVarForBCI(void)
{
  return (Boundary_SelectVarForBCI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectVarForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBCI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT faces ,
 const CCTK_INT boundary_width ,
 const CCTK_INT table_handle ,
 const CCTK_INT var_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBCI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectVarForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectVarForBCI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* faces ,
 const CCTK_INT* boundary_width ,
 const CCTK_INT* table_handle ,
 const CCTK_INT* var_index ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectVarForBCI_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectVarForBCI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Boundary_SelectedGVs_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name) = NULL;
static CCTK_INT (*Boundary_SelectedGVs_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Boundary_SelectedGVs (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name);
CCTK_INT Boundary_SelectedGVs (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name)
{
  CCTK_INT retval;

  if (!Boundary_SelectedGVs_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectedGVs has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectedGVs_C_Wrapper)(GH , array_size , var_indicies , faces , boundary_widths , table_handles , bc_name);
  return (retval);
}

CCTK_INT CCTK_FCALL boundary_selectedgvs_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL boundary_selectedgvs_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Boundary_SelectedGVs_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Boundary_SelectedGVs has not been provided by any active thorn.");
  }

  retval = (*Boundary_SelectedGVs_F_Wrapper)(GH , array_size , var_indicies , faces , boundary_widths , table_handles , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedBoundary_SelectedGVs(void);
CCTK_INT IsAliasedBoundary_SelectedGVs(void)
{
  return (Boundary_SelectedGVs_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasBoundary_SelectedGVs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectedGVs_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectedGVs_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectedGVs_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasBoundary_SelectedGVs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name));
CCTK_INT AliasBoundary_SelectedGVs_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* array_size ,
 CCTK_INT* var_indicies ,
 CCTK_INT* faces ,
 CCTK_INT* boundary_widths ,
 CCTK_INT* table_handles ,
 CCTK_STRING bc_name))
{
  CCTK_INT aliased = Boundary_SelectedGVs_C_Wrapper != NULL;
  if (!aliased)
  {
    Boundary_SelectedGVs_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*CheckVarsForNaN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found) = NULL;
static CCTK_INT (*CheckVarsForNaN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT CheckVarsForNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found);
CCTK_INT CheckVarsForNaN (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found)
{
  CCTK_INT retval;

  if (!CheckVarsForNaN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CheckVarsForNaN has not been provided by any active thorn.");
  }

  retval = (*CheckVarsForNaN_C_Wrapper)(cctkGH , report_max , vars , check_for , action_if_found);
  return (retval);
}

CCTK_INT CCTK_FCALL checkvarsfornan_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 THREE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL checkvarsfornan_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 THREE_FORTSTRING_ARG)
{
  CCTK_INT retval;

THREE_FORTSTRING_CREATE(cctki_string1,cctki_string2,cctki_string3)

  if (!CheckVarsForNaN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function CheckVarsForNaN has not been provided by any active thorn.");
  }

  retval = (*CheckVarsForNaN_F_Wrapper)(cctkGH , report_max , cctki_string1,cctki_string2,cctki_string3);
  free(cctki_string1);
  free(cctki_string2);
  free(cctki_string3);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCheckVarsForNaN(void);
CCTK_INT IsAliasedCheckVarsForNaN(void)
{
  return (CheckVarsForNaN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCheckVarsForNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found));
CCTK_INT AliasCheckVarsForNaN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found))
{
  CCTK_INT aliased = CheckVarsForNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    CheckVarsForNaN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCheckVarsForNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found));
CCTK_INT AliasCheckVarsForNaN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* report_max ,
 CCTK_STRING vars, CCTK_STRING check_for, CCTK_STRING action_if_found))
{
  CCTK_INT aliased = CheckVarsForNaN_C_Wrapper != NULL;
  if (!aliased)
  {
    CheckVarsForNaN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*ConfToPhysInPlace_C_Wrapper) (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;
static void (*ConfToPhysInPlace_F_Wrapper) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void ConfToPhysInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void ConfToPhysInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!ConfToPhysInPlace_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConfToPhysInPlace has not been provided by any active thorn.");
  }

  (*ConfToPhysInPlace_C_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

void CCTK_FCALL conftophysinplace_ (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void CCTK_FCALL conftophysinplace_ (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!ConfToPhysInPlace_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConfToPhysInPlace has not been provided by any active thorn.");
  }

  (*ConfToPhysInPlace_F_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConfToPhysInPlace(void);
CCTK_INT IsAliasedConfToPhysInPlace(void)
{
  return (ConfToPhysInPlace_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConfToPhysInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasConfToPhysInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = ConfToPhysInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    ConfToPhysInPlace_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConfToPhysInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasConfToPhysInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = ConfToPhysInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    ConfToPhysInPlace_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromExteriorBoundary_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromExteriorBoundary_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromExteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromExteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromExteriorBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromExteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromExteriorBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL convertfromexteriorboundary_ (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL convertfromexteriorboundary_ (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromExteriorBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromExteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromExteriorBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromExteriorBoundary(void);
CCTK_INT IsAliasedConvertFromExteriorBoundary(void)
{
  return (ConvertFromExteriorBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromExteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromExteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromExteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromExteriorBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromExteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromExteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 const CCTK_REAL* exterior_min ,
 const CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromExteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromExteriorBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromInteriorBoundary_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromInteriorBoundary_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromInteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromInteriorBoundary (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromInteriorBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromInteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromInteriorBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL convertfrominteriorboundary_ (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL convertfrominteriorboundary_ (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromInteriorBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromInteriorBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromInteriorBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromInteriorBoundary(void);
CCTK_INT IsAliasedConvertFromInteriorBoundary(void)
{
  return (ConvertFromInteriorBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromInteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromInteriorBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromInteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromInteriorBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromInteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromInteriorBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 const CCTK_REAL* interior_min ,
 const CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromInteriorBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromInteriorBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ConvertFromPhysicalBoundary_C_Wrapper) (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*ConvertFromPhysicalBoundary_F_Wrapper) (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ConvertFromPhysicalBoundary (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT ConvertFromPhysicalBoundary (const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromPhysicalBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromPhysicalBoundary_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL convertfromphysicalboundary_ (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL convertfromphysicalboundary_ (const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!ConvertFromPhysicalBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*ConvertFromPhysicalBoundary_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedConvertFromPhysicalBoundary(void);
CCTK_INT IsAliasedConvertFromPhysicalBoundary(void)
{
  return (ConvertFromPhysicalBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromPhysicalBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    ConvertFromPhysicalBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_CoordHandle_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_CoordHandle_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_CoordHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname);
CCTK_INT Coord_CoordHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_CoordHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordHandle_C_Wrapper)(GH , coordname , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL coord_coordhandle_ (const CCTK_POINTER_TO_CONST* GH ,
 TWO_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL coord_coordhandle_ (const CCTK_POINTER_TO_CONST* GH ,
 TWO_FORTSTRING_ARG)
{
  CCTK_INT retval;

TWO_FORTSTRING_CREATE(cctki_string1,cctki_string2)

  if (!Coord_CoordHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordHandle_F_Wrapper)(GH , cctki_string1,cctki_string2);
  free(cctki_string1);
  free(cctki_string2);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_CoordHandle(void);
CCTK_INT IsAliasedCoord_CoordHandle(void)
{
  return (Coord_CoordHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_CoordHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname));
CCTK_INT AliasCoord_CoordHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING coordname, CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_CoordHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_CoordHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname));
CCTK_INT AliasCoord_CoordHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING coordname, CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_CoordHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_CoordRegister_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname) = NULL;
static CCTK_INT (*Coord_CoordRegister_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_CoordRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname);
CCTK_INT Coord_CoordRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname)
{
  CCTK_INT retval;

  if (!Coord_CoordRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordRegister_C_Wrapper)(GH , systemhandle , direction , coordname);
  return (retval);
}

CCTK_INT CCTK_FCALL coord_coordregister_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL coord_coordregister_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_CoordRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_CoordRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_CoordRegister_F_Wrapper)(GH , systemhandle , direction , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_CoordRegister(void);
CCTK_INT IsAliasedCoord_CoordRegister(void)
{
  return (Coord_CoordRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_CoordRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname));
CCTK_INT AliasCoord_CoordRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemhandle ,
 const CCTK_INT direction ,
 CCTK_STRING coordname))
{
  CCTK_INT aliased = Coord_CoordRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_CoordRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname));
CCTK_INT AliasCoord_CoordRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemhandle ,
 const CCTK_INT* direction ,
 CCTK_STRING coordname))
{
  CCTK_INT aliased = Coord_CoordRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_CoordRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_GetDefaultSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim) = NULL;
static CCTK_INT (*Coord_GetDefaultSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_GetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim);
CCTK_INT Coord_GetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim)
{
  CCTK_INT retval;

  if (!Coord_GetDefaultSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GetDefaultSystem_C_Wrapper)(GH , systemdim);
  return (retval);
}

CCTK_INT CCTK_FCALL coord_getdefaultsystem_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim);
CCTK_INT CCTK_FCALL coord_getdefaultsystem_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim)
{
  CCTK_INT retval;

  if (!Coord_GetDefaultSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GetDefaultSystem_F_Wrapper)(GH , systemdim);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_GetDefaultSystem(void);
CCTK_INT IsAliasedCoord_GetDefaultSystem(void)
{
  return (Coord_GetDefaultSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_GetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim));
CCTK_INT AliasCoord_GetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT systemdim))
{
  CCTK_INT aliased = Coord_GetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GetDefaultSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_GetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim));
CCTK_INT AliasCoord_GetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* systemdim))
{
  CCTK_INT aliased = Coord_GetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GetDefaultSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_GroupSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname) = NULL;
static CCTK_INT (*Coord_GroupSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_GroupSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname);
CCTK_INT Coord_GroupSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname)
{
  CCTK_INT retval;

  if (!Coord_GroupSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GroupSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GroupSystem_C_Wrapper)(GH , groupname);
  return (retval);
}

CCTK_INT CCTK_FCALL coord_groupsystem_ (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL coord_groupsystem_ (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_GroupSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_GroupSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_GroupSystem_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_GroupSystem(void);
CCTK_INT IsAliasedCoord_GroupSystem(void)
{
  return (Coord_GroupSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_GroupSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname));
CCTK_INT AliasCoord_GroupSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING groupname))
{
  CCTK_INT aliased = Coord_GroupSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GroupSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_GroupSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname));
CCTK_INT AliasCoord_GroupSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING groupname))
{
  CCTK_INT aliased = Coord_GroupSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_GroupSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SetDefaultSystem_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SetDefaultSystem_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname);
CCTK_INT Coord_SetDefaultSystem (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SetDefaultSystem_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_SetDefaultSystem_C_Wrapper)(GH , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL coord_setdefaultsystem_ (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL coord_setdefaultsystem_ (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SetDefaultSystem_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SetDefaultSystem has not been provided by any active thorn.");
  }

  retval = (*Coord_SetDefaultSystem_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SetDefaultSystem(void);
CCTK_INT IsAliasedCoord_SetDefaultSystem(void)
{
  return (Coord_SetDefaultSystem_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SetDefaultSystem_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SetDefaultSystem_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SetDefaultSystem_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SetDefaultSystem_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SetDefaultSystem_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SystemHandle_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SystemHandle_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SystemHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname);
CCTK_INT Coord_SystemHandle (const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SystemHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemHandle_C_Wrapper)(GH , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL coord_systemhandle_ (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL coord_systemhandle_ (const CCTK_POINTER_TO_CONST* GH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SystemHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemHandle has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemHandle_F_Wrapper)(GH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SystemHandle(void);
CCTK_INT IsAliasedCoord_SystemHandle(void)
{
  return (Coord_SystemHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SystemHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemHandle_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SystemHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemHandle_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Coord_SystemRegister_C_Wrapper) (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname) = NULL;
static CCTK_INT (*Coord_SystemRegister_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Coord_SystemRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname);
CCTK_INT Coord_SystemRegister (const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname)
{
  CCTK_INT retval;

  if (!Coord_SystemRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemRegister_C_Wrapper)(GH , dim , systemname);
  return (retval);
}

CCTK_INT CCTK_FCALL coord_systemregister_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL coord_systemregister_ (const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!Coord_SystemRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Coord_SystemRegister has not been provided by any active thorn.");
  }

  retval = (*Coord_SystemRegister_F_Wrapper)(GH , dim , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedCoord_SystemRegister(void);
CCTK_INT IsAliasedCoord_SystemRegister(void)
{
  return (Coord_SystemRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasCoord_SystemRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemRegister_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH ,
 const CCTK_INT dim ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasCoord_SystemRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname));
CCTK_INT AliasCoord_SystemRegister_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH ,
 const CCTK_INT* dim ,
 CCTK_STRING systemname))
{
  CCTK_INT aliased = Coord_SystemRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    Coord_SystemRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*Diff_coeff_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle) = NULL;
static void (*Diff_coeff_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void Diff_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle);
void Diff_coeff (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle)
{
  if (!Diff_coeff_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_coeff has not been provided by any active thorn.");
  }

  (*Diff_coeff_C_Wrapper)(cctkGH , dir , nsize , imin , imax , q , table_handle);
}

void CCTK_FCALL diff_coeff_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle);
void CCTK_FCALL diff_coeff_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle)
{
  if (!Diff_coeff_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Diff_coeff has not been provided by any active thorn.");
  }

  (*Diff_coeff_F_Wrapper)(cctkGH , dir , nsize , imin , imax , q , table_handle);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDiff_coeff(void);
CCTK_INT IsAliasedDiff_coeff(void)
{
  return (Diff_coeff_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDiff_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle));
CCTK_INT AliasDiff_coeff_C(void (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT dir ,
 const CCTK_INT nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT table_handle))
{
  CCTK_INT aliased = Diff_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_coeff_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDiff_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle));
CCTK_INT AliasDiff_coeff_F(void (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* dir ,
 const CCTK_INT* nsize ,
 CCTK_INT* imin ,
 CCTK_INT* imax ,
 CCTK_REAL* q ,
 const CCTK_INT* table_handle))
{
  CCTK_INT aliased = Diff_coeff_C_Wrapper != NULL;
  if (!aliased)
  {
    Diff_coeff_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*DriverInterpolate_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;
static CCTK_INT (*DriverInterpolate_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT DriverInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT DriverInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!DriverInterpolate_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function DriverInterpolate has not been provided by any active thorn.");
  }

  retval = (*DriverInterpolate_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL driverinterpolate_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL driverinterpolate_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!DriverInterpolate_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function DriverInterpolate has not been provided by any active thorn.");
  }

  retval = (*DriverInterpolate_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedDriverInterpolate(void);
CCTK_INT IsAliasedDriverInterpolate(void)
{
  return (DriverInterpolate_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasDriverInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasDriverInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = DriverInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    DriverInterpolate_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasDriverInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasDriverInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = DriverInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    DriverInterpolate_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*EnableProlongating_C_Wrapper) (const CCTK_INT Status) = NULL;
static CCTK_INT (*EnableProlongating_F_Wrapper) (const CCTK_INT* Status) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT EnableProlongating (const CCTK_INT Status);
CCTK_INT EnableProlongating (const CCTK_INT Status)
{
  CCTK_INT retval;

  if (!EnableProlongating_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EnableProlongating has not been provided by any active thorn.");
  }

  retval = (*EnableProlongating_C_Wrapper)(Status);
  return (retval);
}

CCTK_INT CCTK_FCALL enableprolongating_ (const CCTK_INT* Status);
CCTK_INT CCTK_FCALL enableprolongating_ (const CCTK_INT* Status)
{
  CCTK_INT retval;

  if (!EnableProlongating_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function EnableProlongating has not been provided by any active thorn.");
  }

  retval = (*EnableProlongating_F_Wrapper)(Status);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedEnableProlongating(void);
CCTK_INT IsAliasedEnableProlongating(void)
{
  return (EnableProlongating_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasEnableProlongating_C(CCTK_INT (*func)(const CCTK_INT Status));
CCTK_INT AliasEnableProlongating_C(CCTK_INT (*func)(const CCTK_INT Status))
{
  CCTK_INT aliased = EnableProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    EnableProlongating_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasEnableProlongating_F(CCTK_INT (*func)(const CCTK_INT* Status));
CCTK_INT AliasEnableProlongating_F(CCTK_INT (*func)(const CCTK_INT* Status))
{
  CCTK_INT aliased = EnableProlongating_C_Wrapper != NULL;
  if (!aliased)
  {
    EnableProlongating_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*ExtrapolateGammas_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var) = NULL;
static CCTK_INT (*ExtrapolateGammas_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT ExtrapolateGammas (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var);
CCTK_INT ExtrapolateGammas (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var)
{
  CCTK_INT retval;

  if (!ExtrapolateGammas_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ExtrapolateGammas has not been provided by any active thorn.");
  }

  retval = (*ExtrapolateGammas_C_Wrapper)(cctkGH , var);
  return (retval);
}

CCTK_INT CCTK_FCALL extrapolategammas_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var);
CCTK_INT CCTK_FCALL extrapolategammas_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var)
{
  CCTK_INT retval;

  if (!ExtrapolateGammas_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function ExtrapolateGammas has not been provided by any active thorn.");
  }

  retval = (*ExtrapolateGammas_F_Wrapper)(cctkGH , var);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedExtrapolateGammas(void);
CCTK_INT IsAliasedExtrapolateGammas(void)
{
  return (ExtrapolateGammas_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasExtrapolateGammas_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var));
CCTK_INT AliasExtrapolateGammas_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_REAL* var))
{
  CCTK_INT aliased = ExtrapolateGammas_C_Wrapper != NULL;
  if (!aliased)
  {
    ExtrapolateGammas_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasExtrapolateGammas_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var));
CCTK_INT AliasExtrapolateGammas_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_REAL* var))
{
  CCTK_INT aliased = ExtrapolateGammas_C_Wrapper != NULL;
  if (!aliased)
  {
    ExtrapolateGammas_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetBoundarySizesAndTypes_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd) = NULL;
static CCTK_INT (*GetBoundarySizesAndTypes_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetBoundarySizesAndTypes (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd);
CCTK_INT GetBoundarySizesAndTypes (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd)
{
  CCTK_INT retval;

  if (!GetBoundarySizesAndTypes_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySizesAndTypes has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySizesAndTypes_C_Wrapper)(cctkGH , size , bndsize , is_ghostbnd , is_symbnd , is_physbnd);
  return (retval);
}

CCTK_INT CCTK_FCALL getboundarysizesandtypes_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd);
CCTK_INT CCTK_FCALL getboundarysizesandtypes_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd)
{
  CCTK_INT retval;

  if (!GetBoundarySizesAndTypes_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySizesAndTypes has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySizesAndTypes_F_Wrapper)(cctkGH , size , bndsize , is_ghostbnd , is_symbnd , is_physbnd);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetBoundarySizesAndTypes(void);
CCTK_INT IsAliasedGetBoundarySizesAndTypes(void)
{
  return (GetBoundarySizesAndTypes_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetBoundarySizesAndTypes_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd));
CCTK_INT AliasGetBoundarySizesAndTypes_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd))
{
  CCTK_INT aliased = GetBoundarySizesAndTypes_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySizesAndTypes_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetBoundarySizesAndTypes_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd));
CCTK_INT AliasGetBoundarySizesAndTypes_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bndsize ,
 CCTK_INT* is_ghostbnd ,
 CCTK_INT* is_symbnd ,
 CCTK_INT* is_physbnd))
{
  CCTK_INT aliased = GetBoundarySizesAndTypes_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySizesAndTypes_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetBoundarySpecification_C_Wrapper) (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;
static CCTK_INT (*GetBoundarySpecification_F_Wrapper) (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetBoundarySpecification (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT GetBoundarySpecification (const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!GetBoundarySpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySpecification_C_Wrapper)(size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

CCTK_INT CCTK_FCALL getboundaryspecification_ (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT CCTK_FCALL getboundaryspecification_ (const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!GetBoundarySpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*GetBoundarySpecification_F_Wrapper)(size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetBoundarySpecification(void);
CCTK_INT IsAliasedGetBoundarySpecification(void)
{
  return (GetBoundarySpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasGetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasGetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetBoundarySpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetDomainSpecification_C_Wrapper) (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;
static CCTK_INT (*GetDomainSpecification_F_Wrapper) (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetDomainSpecification (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT GetDomainSpecification (const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!GetDomainSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*GetDomainSpecification_C_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL getdomainspecification_ (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL getdomainspecification_ (const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!GetDomainSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*GetDomainSpecification_F_Wrapper)(size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetDomainSpecification(void);
CCTK_INT IsAliasedGetDomainSpecification(void)
{
  return (GetDomainSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasGetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetDomainSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasGetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    GetDomainSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*GetSymmetryBoundaries_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd) = NULL;
static CCTK_INT (*GetSymmetryBoundaries_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT GetSymmetryBoundaries (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd);
CCTK_INT GetSymmetryBoundaries (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd)
{
  CCTK_INT retval;

  if (!GetSymmetryBoundaries_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetSymmetryBoundaries has not been provided by any active thorn.");
  }

  retval = (*GetSymmetryBoundaries_C_Wrapper)(cctkGH , size , symbnd);
  return (retval);
}

CCTK_INT CCTK_FCALL getsymmetryboundaries_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd);
CCTK_INT CCTK_FCALL getsymmetryboundaries_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd)
{
  CCTK_INT retval;

  if (!GetSymmetryBoundaries_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function GetSymmetryBoundaries has not been provided by any active thorn.");
  }

  retval = (*GetSymmetryBoundaries_F_Wrapper)(cctkGH , size , symbnd);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedGetSymmetryBoundaries(void);
CCTK_INT IsAliasedGetSymmetryBoundaries(void)
{
  return (GetSymmetryBoundaries_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasGetSymmetryBoundaries_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd));
CCTK_INT AliasGetSymmetryBoundaries_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* symbnd))
{
  CCTK_INT aliased = GetSymmetryBoundaries_C_Wrapper != NULL;
  if (!aliased)
  {
    GetSymmetryBoundaries_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasGetSymmetryBoundaries_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd));
CCTK_INT AliasGetSymmetryBoundaries_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* symbnd))
{
  CCTK_INT aliased = GetSymmetryBoundaries_C_Wrapper != NULL;
  if (!aliased)
  {
    GetSymmetryBoundaries_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_FreeMapping_C_Wrapper) (const CCTK_INT mapping_handle) = NULL;
static CCTK_INT (*Hyperslab_FreeMapping_F_Wrapper) (const CCTK_INT* mapping_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_FreeMapping (const CCTK_INT mapping_handle);
CCTK_INT Hyperslab_FreeMapping (const CCTK_INT mapping_handle)
{
  CCTK_INT retval;

  if (!Hyperslab_FreeMapping_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_FreeMapping has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_FreeMapping_C_Wrapper)(mapping_handle);
  return (retval);
}

CCTK_INT CCTK_FCALL hyperslab_freemapping_ (const CCTK_INT* mapping_handle);
CCTK_INT CCTK_FCALL hyperslab_freemapping_ (const CCTK_INT* mapping_handle)
{
  CCTK_INT retval;

  if (!Hyperslab_FreeMapping_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_FreeMapping has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_FreeMapping_F_Wrapper)(mapping_handle);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_FreeMapping(void);
CCTK_INT IsAliasedHyperslab_FreeMapping(void)
{
  return (Hyperslab_FreeMapping_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_FreeMapping_C(CCTK_INT (*func)(const CCTK_INT mapping_handle));
CCTK_INT AliasHyperslab_FreeMapping_C(CCTK_INT (*func)(const CCTK_INT mapping_handle))
{
  CCTK_INT aliased = Hyperslab_FreeMapping_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_FreeMapping_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_FreeMapping_F(CCTK_INT (*func)(const CCTK_INT* mapping_handle));
CCTK_INT AliasHyperslab_FreeMapping_F(CCTK_INT (*func)(const CCTK_INT* mapping_handle))
{
  CCTK_INT aliased = Hyperslab_FreeMapping_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_FreeMapping_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_Get_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata) = NULL;
static CCTK_INT (*Hyperslab_Get_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_Get (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata);
CCTK_INT Hyperslab_Get (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata)
{
  CCTK_INT retval;

  if (!Hyperslab_Get_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_Get has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_Get_C_Wrapper)(cctkGH , mapping_handle , proc , vindex , timelevel , hdatatype , hdata);
  return (retval);
}

CCTK_INT CCTK_FCALL hyperslab_get_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata);
CCTK_INT CCTK_FCALL hyperslab_get_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata)
{
  CCTK_INT retval;

  if (!Hyperslab_Get_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_Get has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_Get_F_Wrapper)(cctkGH , mapping_handle , proc , vindex , timelevel , hdatatype , hdata);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_Get(void);
CCTK_INT IsAliasedHyperslab_Get(void)
{
  return (Hyperslab_Get_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_Get_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata));
CCTK_INT AliasHyperslab_Get_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT proc ,
 const CCTK_INT vindex ,
 const CCTK_INT timelevel ,
 const CCTK_INT hdatatype ,
 const CCTK_POINTER hdata))
{
  CCTK_INT aliased = Hyperslab_Get_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_Get_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_Get_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata));
CCTK_INT AliasHyperslab_Get_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* proc ,
 const CCTK_INT* vindex ,
 const CCTK_INT* timelevel ,
 const CCTK_INT* hdatatype ,
 const CCTK_POINTER* hdata))
{
  CCTK_INT aliased = Hyperslab_Get_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_Get_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_GetList_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals) = NULL;
static CCTK_INT (*Hyperslab_GetList_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_GetList (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals);
CCTK_INT Hyperslab_GetList (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals)
{
  CCTK_INT retval;

  if (!Hyperslab_GetList_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GetList has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GetList_C_Wrapper)(cctkGH , mapping_handle , num_arrays , procs , vindices , timelevels , hdatatypes , hdata , retvals);
  return (retval);
}

CCTK_INT CCTK_FCALL hyperslab_getlist_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals);
CCTK_INT CCTK_FCALL hyperslab_getlist_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals)
{
  CCTK_INT retval;

  if (!Hyperslab_GetList_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GetList has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GetList_F_Wrapper)(cctkGH , mapping_handle , num_arrays , procs , vindices , timelevels , hdatatypes , hdata , retvals);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_GetList(void);
CCTK_INT IsAliasedHyperslab_GetList(void)
{
  return (Hyperslab_GetList_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_GetList_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals));
CCTK_INT AliasHyperslab_GetList_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT mapping_handle ,
 const CCTK_INT num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals))
{
  CCTK_INT aliased = Hyperslab_GetList_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GetList_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_GetList_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals));
CCTK_INT AliasHyperslab_GetList_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* mapping_handle ,
 const CCTK_INT* num_arrays ,
 const CCTK_INT* procs ,
 const CCTK_INT* vindices ,
 const CCTK_INT* timelevels ,
 const CCTK_INT* hdatatypes ,
 const CCTK_POINTER* hdata ,
 CCTK_INT* retvals))
{
  CCTK_INT aliased = Hyperslab_GetList_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GetList_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_GlobalMappingByIndex_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize) = NULL;
static CCTK_INT (*Hyperslab_GlobalMappingByIndex_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_GlobalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize);
CCTK_INT Hyperslab_GlobalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize)
{
  CCTK_INT retval;

  if (!Hyperslab_GlobalMappingByIndex_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GlobalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GlobalMappingByIndex_C_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize);
  return (retval);
}

CCTK_INT CCTK_FCALL hyperslab_globalmappingbyindex_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize);
CCTK_INT CCTK_FCALL hyperslab_globalmappingbyindex_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize)
{
  CCTK_INT retval;

  if (!Hyperslab_GlobalMappingByIndex_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_GlobalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_GlobalMappingByIndex_F_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_GlobalMappingByIndex(void);
CCTK_INT IsAliasedHyperslab_GlobalMappingByIndex(void)
{
  return (Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_GlobalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize));
CCTK_INT AliasHyperslab_GlobalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize))
{
  CCTK_INT aliased = Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GlobalMappingByIndex_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_GlobalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize));
CCTK_INT AliasHyperslab_GlobalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize))
{
  CCTK_INT aliased = Hyperslab_GlobalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_GlobalMappingByIndex_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*Hyperslab_LocalMappingByIndex_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global) = NULL;
static CCTK_INT (*Hyperslab_LocalMappingByIndex_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT Hyperslab_LocalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global);
CCTK_INT Hyperslab_LocalMappingByIndex (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global)
{
  CCTK_INT retval;

  if (!Hyperslab_LocalMappingByIndex_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_LocalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_LocalMappingByIndex_C_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize_local , hsize_global , hoffset_global);
  return (retval);
}

CCTK_INT CCTK_FCALL hyperslab_localmappingbyindex_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global);
CCTK_INT CCTK_FCALL hyperslab_localmappingbyindex_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global)
{
  CCTK_INT retval;

  if (!Hyperslab_LocalMappingByIndex_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function Hyperslab_LocalMappingByIndex has not been provided by any active thorn.");
  }

  retval = (*Hyperslab_LocalMappingByIndex_F_Wrapper)(cctkGH , vindex , hdim , direction , origin , extent , downsample , table_handle , conversion_fn , hsize_local , hsize_global , hoffset_global);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedHyperslab_LocalMappingByIndex(void);
CCTK_INT IsAliasedHyperslab_LocalMappingByIndex(void)
{
  return (Hyperslab_LocalMappingByIndex_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasHyperslab_LocalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global));
CCTK_INT AliasHyperslab_LocalMappingByIndex_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT vindex ,
 const CCTK_INT hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT nelems ,
 const CCTK_INT src_stride ,
 const CCTK_INT dst_stride ,
 const CCTK_INT src_type ,
 const CCTK_INT dst_type ,
 const CCTK_POINTER_TO_CONST from ,
 const CCTK_POINTER to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global))
{
  CCTK_INT aliased = Hyperslab_LocalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_LocalMappingByIndex_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasHyperslab_LocalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global));
CCTK_INT AliasHyperslab_LocalMappingByIndex_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* vindex ,
 const CCTK_INT* hdim ,
 const CCTK_INT* direction ,
 const CCTK_INT* origin ,
 const CCTK_INT* extent ,
 const CCTK_INT* downsample ,
 const CCTK_INT* table_handle ,
 CCTK_INT (*const conversion_fn)(const CCTK_INT* nelems ,
 const CCTK_INT* src_stride ,
 const CCTK_INT* dst_stride ,
 const CCTK_INT* src_type ,
 const CCTK_INT* dst_type ,
 const CCTK_POINTER_TO_CONST* from ,
 const CCTK_POINTER* to) ,
 CCTK_INT* hsize_local ,
 CCTK_INT* hsize_global ,
 CCTK_INT* hoffset_global))
{
  CCTK_INT aliased = Hyperslab_LocalMappingByIndex_C_Wrapper != NULL;
  if (!aliased)
  {
    Hyperslab_LocalMappingByIndex_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*IO_TruncateOutputFiles_C_Wrapper) (const CCTK_POINTER_TO_CONST GH) = NULL;
static CCTK_INT (*IO_TruncateOutputFiles_F_Wrapper) (const CCTK_POINTER_TO_CONST* GH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT IO_TruncateOutputFiles (const CCTK_POINTER_TO_CONST GH);
CCTK_INT IO_TruncateOutputFiles (const CCTK_POINTER_TO_CONST GH)
{
  CCTK_INT retval;

  if (!IO_TruncateOutputFiles_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_TruncateOutputFiles has not been provided by any active thorn.");
  }

  retval = (*IO_TruncateOutputFiles_C_Wrapper)(GH);
  return (retval);
}

CCTK_INT CCTK_FCALL io_truncateoutputfiles_ (const CCTK_POINTER_TO_CONST* GH);
CCTK_INT CCTK_FCALL io_truncateoutputfiles_ (const CCTK_POINTER_TO_CONST* GH)
{
  CCTK_INT retval;

  if (!IO_TruncateOutputFiles_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function IO_TruncateOutputFiles has not been provided by any active thorn.");
  }

  retval = (*IO_TruncateOutputFiles_F_Wrapper)(GH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedIO_TruncateOutputFiles(void);
CCTK_INT IsAliasedIO_TruncateOutputFiles(void)
{
  return (IO_TruncateOutputFiles_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasIO_TruncateOutputFiles_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH));
CCTK_INT AliasIO_TruncateOutputFiles_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST GH))
{
  CCTK_INT aliased = IO_TruncateOutputFiles_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_TruncateOutputFiles_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasIO_TruncateOutputFiles_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH));
CCTK_INT AliasIO_TruncateOutputFiles_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* GH))
{
  CCTK_INT aliased = IO_TruncateOutputFiles_C_Wrapper != NULL;
  if (!aliased)
  {
    IO_TruncateOutputFiles_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*LinearCombination_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs) = NULL;
static CCTK_INT (*LinearCombination_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT LinearCombination (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs);
CCTK_INT LinearCombination (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs)
{
  CCTK_INT retval;

  if (!LinearCombination_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function LinearCombination has not been provided by any active thorn.");
  }

  retval = (*LinearCombination_C_Wrapper)(cctkGH , var , scale , srcs , tls , facts , nsrcs);
  return (retval);
}

CCTK_INT CCTK_FCALL linearcombination_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs);
CCTK_INT CCTK_FCALL linearcombination_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs)
{
  CCTK_INT retval;

  if (!LinearCombination_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function LinearCombination has not been provided by any active thorn.");
  }

  retval = (*LinearCombination_F_Wrapper)(cctkGH , var , scale , srcs , tls , facts , nsrcs);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedLinearCombination(void);
CCTK_INT IsAliasedLinearCombination(void)
{
  return (LinearCombination_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasLinearCombination_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs));
CCTK_INT AliasLinearCombination_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT var ,
 const CCTK_REAL scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT nsrcs))
{
  CCTK_INT aliased = LinearCombination_C_Wrapper != NULL;
  if (!aliased)
  {
    LinearCombination_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasLinearCombination_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs));
CCTK_INT AliasLinearCombination_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* var ,
 const CCTK_REAL* scale ,
 const CCTK_INT* srcs ,
 const CCTK_INT* tls ,
 const CCTK_REAL* facts ,
 const CCTK_INT* nsrcs))
{
  CCTK_INT aliased = LinearCombination_C_Wrapper != NULL;
  if (!aliased)
  {
    LinearCombination_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToConstrained_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLChangeToConstrained_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToConstrained (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLChangeToConstrained (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToConstrained_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToConstrained_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molchangetoconstrained_ (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL molchangetoconstrained_ (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToConstrained_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToConstrained_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToConstrained(void);
CCTK_INT IsAliasedMoLChangeToConstrained(void)
{
  return (MoLChangeToConstrained_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLChangeToConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLChangeToConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToConstrained_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLChangeToConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLChangeToConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToConstrained_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToEvolved_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLChangeToEvolved_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLChangeToEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolved_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolved_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molchangetoevolved_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL molchangetoevolved_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolved_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolved_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToEvolved(void);
CCTK_INT IsAliasedMoLChangeToEvolved(void)
{
  return (MoLChangeToEvolved_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLChangeToEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLChangeToEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolved_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLChangeToEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLChangeToEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolved_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToEvolvedSlow_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow) = NULL;
static CCTK_INT (*MoLChangeToEvolvedSlow_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow);
CCTK_INT MoLChangeToEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolvedSlow_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolvedSlow_C_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

CCTK_INT CCTK_FCALL molchangetoevolvedslow_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow);
CCTK_INT CCTK_FCALL molchangetoevolvedslow_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLChangeToEvolvedSlow_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToEvolvedSlow_F_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToEvolvedSlow(void);
CCTK_INT IsAliasedMoLChangeToEvolvedSlow(void)
{
  return (MoLChangeToEvolvedSlow_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow));
CCTK_INT AliasMoLChangeToEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow))
{
  CCTK_INT aliased = MoLChangeToEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolvedSlow_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow));
CCTK_INT AliasMoLChangeToEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow))
{
  CCTK_INT aliased = MoLChangeToEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToEvolvedSlow_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToNone_C_Wrapper) (const CCTK_INT RemoveIndex) = NULL;
static CCTK_INT (*MoLChangeToNone_F_Wrapper) (const CCTK_INT* RemoveIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToNone (const CCTK_INT RemoveIndex);
CCTK_INT MoLChangeToNone (const CCTK_INT RemoveIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToNone_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToNone has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToNone_C_Wrapper)(RemoveIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molchangetonone_ (const CCTK_INT* RemoveIndex);
CCTK_INT CCTK_FCALL molchangetonone_ (const CCTK_INT* RemoveIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToNone_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToNone has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToNone_F_Wrapper)(RemoveIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToNone(void);
CCTK_INT IsAliasedMoLChangeToNone(void)
{
  return (MoLChangeToNone_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToNone_C(CCTK_INT (*func)(const CCTK_INT RemoveIndex));
CCTK_INT AliasMoLChangeToNone_C(CCTK_INT (*func)(const CCTK_INT RemoveIndex))
{
  CCTK_INT aliased = MoLChangeToNone_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToNone_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToNone_F(CCTK_INT (*func)(const CCTK_INT* RemoveIndex));
CCTK_INT AliasMoLChangeToNone_F(CCTK_INT (*func)(const CCTK_INT* RemoveIndex))
{
  CCTK_INT aliased = MoLChangeToNone_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToNone_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLChangeToSaveAndRestore_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLChangeToSaveAndRestore_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLChangeToSaveAndRestore (const CCTK_INT SandRIndex);
CCTK_INT MoLChangeToSaveAndRestore (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToSaveAndRestore_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToSaveAndRestore_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molchangetosaveandrestore_ (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL molchangetosaveandrestore_ (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLChangeToSaveAndRestore_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLChangeToSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLChangeToSaveAndRestore_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLChangeToSaveAndRestore(void);
CCTK_INT IsAliasedMoLChangeToSaveAndRestore(void)
{
  return (MoLChangeToSaveAndRestore_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLChangeToSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLChangeToSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLChangeToSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToSaveAndRestore_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLChangeToSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLChangeToSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLChangeToSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLChangeToSaveAndRestore_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLNumIntegratorSubsteps_C_Wrapper) (void) = NULL;
static CCTK_INT (*MoLNumIntegratorSubsteps_F_Wrapper) (void) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLNumIntegratorSubsteps (void);
CCTK_INT MoLNumIntegratorSubsteps (void)
{
  CCTK_INT retval;

  if (!MoLNumIntegratorSubsteps_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLNumIntegratorSubsteps has not been provided by any active thorn.");
  }

  retval = (*MoLNumIntegratorSubsteps_C_Wrapper)();
  return (retval);
}

CCTK_INT CCTK_FCALL molnumintegratorsubsteps_ (void);
CCTK_INT CCTK_FCALL molnumintegratorsubsteps_ (void)
{
  CCTK_INT retval;

  if (!MoLNumIntegratorSubsteps_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLNumIntegratorSubsteps has not been provided by any active thorn.");
  }

  retval = (*MoLNumIntegratorSubsteps_F_Wrapper)();
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLNumIntegratorSubsteps(void);
CCTK_INT IsAliasedMoLNumIntegratorSubsteps(void)
{
  return (MoLNumIntegratorSubsteps_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLNumIntegratorSubsteps_C(CCTK_INT (*func)(void));
CCTK_INT AliasMoLNumIntegratorSubsteps_C(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = MoLNumIntegratorSubsteps_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLNumIntegratorSubsteps_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLNumIntegratorSubsteps_F(CCTK_INT (*func)(void));
CCTK_INT AliasMoLNumIntegratorSubsteps_F(CCTK_INT (*func)(void))
{
  CCTK_INT aliased = MoLNumIntegratorSubsteps_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLNumIntegratorSubsteps_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLQueryEvolvedRHS_C_Wrapper) (const CCTK_INT EvolvedIndex) = NULL;
static CCTK_INT (*MoLQueryEvolvedRHS_F_Wrapper) (const CCTK_INT* EvolvedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLQueryEvolvedRHS (const CCTK_INT EvolvedIndex);
CCTK_INT MoLQueryEvolvedRHS (const CCTK_INT EvolvedIndex)
{
  CCTK_INT retval;

  if (!MoLQueryEvolvedRHS_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLQueryEvolvedRHS has not been provided by any active thorn.");
  }

  retval = (*MoLQueryEvolvedRHS_C_Wrapper)(EvolvedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molqueryevolvedrhs_ (const CCTK_INT* EvolvedIndex);
CCTK_INT CCTK_FCALL molqueryevolvedrhs_ (const CCTK_INT* EvolvedIndex)
{
  CCTK_INT retval;

  if (!MoLQueryEvolvedRHS_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLQueryEvolvedRHS has not been provided by any active thorn.");
  }

  retval = (*MoLQueryEvolvedRHS_F_Wrapper)(EvolvedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLQueryEvolvedRHS(void);
CCTK_INT IsAliasedMoLQueryEvolvedRHS(void)
{
  return (MoLQueryEvolvedRHS_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLQueryEvolvedRHS_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex));
CCTK_INT AliasMoLQueryEvolvedRHS_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex))
{
  CCTK_INT aliased = MoLQueryEvolvedRHS_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLQueryEvolvedRHS_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLQueryEvolvedRHS_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex));
CCTK_INT AliasMoLQueryEvolvedRHS_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex))
{
  CCTK_INT aliased = MoLQueryEvolvedRHS_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLQueryEvolvedRHS_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterConstrained_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLRegisterConstrained_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterConstrained (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLRegisterConstrained (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrained_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrained_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molregisterconstrained_ (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL molregisterconstrained_ (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrained_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrained has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrained_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterConstrained(void);
CCTK_INT IsAliasedMoLRegisterConstrained(void)
{
  return (MoLRegisterConstrained_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrained_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrained_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrained_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrained_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrained_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterConstrainedGroup_C_Wrapper) (const CCTK_INT ConstrainedIndex) = NULL;
static CCTK_INT (*MoLRegisterConstrainedGroup_F_Wrapper) (const CCTK_INT* ConstrainedIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterConstrainedGroup (const CCTK_INT ConstrainedIndex);
CCTK_INT MoLRegisterConstrainedGroup (const CCTK_INT ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrainedGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrainedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrainedGroup_C_Wrapper)(ConstrainedIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molregisterconstrainedgroup_ (const CCTK_INT* ConstrainedIndex);
CCTK_INT CCTK_FCALL molregisterconstrainedgroup_ (const CCTK_INT* ConstrainedIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterConstrainedGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterConstrainedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterConstrainedGroup_F_Wrapper)(ConstrainedIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterConstrainedGroup(void);
CCTK_INT IsAliasedMoLRegisterConstrainedGroup(void)
{
  return (MoLRegisterConstrainedGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterConstrainedGroup_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrainedGroup_C(CCTK_INT (*func)(const CCTK_INT ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrainedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrainedGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterConstrainedGroup_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex));
CCTK_INT AliasMoLRegisterConstrainedGroup_F(CCTK_INT (*func)(const CCTK_INT* ConstrainedIndex))
{
  CCTK_INT aliased = MoLRegisterConstrainedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterConstrainedGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolved_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLRegisterEvolved_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLRegisterEvolved (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolved_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolved_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molregisterevolved_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL molregisterevolved_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolved_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolved has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolved_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolved(void);
CCTK_INT IsAliasedMoLRegisterEvolved(void)
{
  return (MoLRegisterEvolved_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLRegisterEvolved_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolved_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLRegisterEvolved_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolved_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolved_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolvedGroup_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex) = NULL;
static CCTK_INT (*MoLRegisterEvolvedGroup_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolvedGroup (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex);
CCTK_INT MoLRegisterEvolvedGroup (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroup_C_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molregisterevolvedgroup_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex);
CCTK_INT CCTK_FCALL molregisterevolvedgroup_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroup_F_Wrapper)(EvolvedIndex , RHSIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolvedGroup(void);
CCTK_INT IsAliasedMoLRegisterEvolvedGroup(void)
{
  return (MoLRegisterEvolvedGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolvedGroup_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex));
CCTK_INT AliasMoLRegisterEvolvedGroup_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolvedGroup_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex));
CCTK_INT AliasMoLRegisterEvolvedGroup_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndex))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolvedGroupSlow_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow) = NULL;
static CCTK_INT (*MoLRegisterEvolvedGroupSlow_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolvedGroupSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow);
CCTK_INT MoLRegisterEvolvedGroupSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroupSlow_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroupSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroupSlow_C_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

CCTK_INT CCTK_FCALL molregisterevolvedgroupslow_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow);
CCTK_INT CCTK_FCALL molregisterevolvedgroupslow_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedGroupSlow_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedGroupSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedGroupSlow_F_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolvedGroupSlow(void);
CCTK_INT IsAliasedMoLRegisterEvolvedGroupSlow(void)
{
  return (MoLRegisterEvolvedGroupSlow_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolvedGroupSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedGroupSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroupSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroupSlow_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolvedGroupSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedGroupSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedGroupSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedGroupSlow_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterEvolvedSlow_C_Wrapper) (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow) = NULL;
static CCTK_INT (*MoLRegisterEvolvedSlow_F_Wrapper) (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow);
CCTK_INT MoLRegisterEvolvedSlow (const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedSlow_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedSlow_C_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

CCTK_INT CCTK_FCALL molregisterevolvedslow_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow);
CCTK_INT CCTK_FCALL molregisterevolvedslow_ (const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow)
{
  CCTK_INT retval;

  if (!MoLRegisterEvolvedSlow_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterEvolvedSlow has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterEvolvedSlow_F_Wrapper)(EvolvedIndex , RHSIndexSlow);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterEvolvedSlow(void);
CCTK_INT IsAliasedMoLRegisterEvolvedSlow(void)
{
  return (MoLRegisterEvolvedSlow_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedSlow_C(CCTK_INT (*func)(const CCTK_INT EvolvedIndex ,
 const CCTK_INT RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedSlow_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow));
CCTK_INT AliasMoLRegisterEvolvedSlow_F(CCTK_INT (*func)(const CCTK_INT* EvolvedIndex ,
 const CCTK_INT* RHSIndexSlow))
{
  CCTK_INT aliased = MoLRegisterEvolvedSlow_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterEvolvedSlow_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterSaveAndRestore_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLRegisterSaveAndRestore_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterSaveAndRestore (const CCTK_INT SandRIndex);
CCTK_INT MoLRegisterSaveAndRestore (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestore_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestore_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molregistersaveandrestore_ (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL molregistersaveandrestore_ (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestore_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestore has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestore_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterSaveAndRestore(void);
CCTK_INT IsAliasedMoLRegisterSaveAndRestore(void)
{
  return (MoLRegisterSaveAndRestore_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestore_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestore_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestore_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestore_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestore_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MoLRegisterSaveAndRestoreGroup_C_Wrapper) (const CCTK_INT SandRIndex) = NULL;
static CCTK_INT (*MoLRegisterSaveAndRestoreGroup_F_Wrapper) (const CCTK_INT* SandRIndex) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MoLRegisterSaveAndRestoreGroup (const CCTK_INT SandRIndex);
CCTK_INT MoLRegisterSaveAndRestoreGroup (const CCTK_INT SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestoreGroup_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestoreGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestoreGroup_C_Wrapper)(SandRIndex);
  return (retval);
}

CCTK_INT CCTK_FCALL molregistersaveandrestoregroup_ (const CCTK_INT* SandRIndex);
CCTK_INT CCTK_FCALL molregistersaveandrestoregroup_ (const CCTK_INT* SandRIndex)
{
  CCTK_INT retval;

  if (!MoLRegisterSaveAndRestoreGroup_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MoLRegisterSaveAndRestoreGroup has not been provided by any active thorn.");
  }

  retval = (*MoLRegisterSaveAndRestoreGroup_F_Wrapper)(SandRIndex);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMoLRegisterSaveAndRestoreGroup(void);
CCTK_INT IsAliasedMoLRegisterSaveAndRestoreGroup(void)
{
  return (MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_C(CCTK_INT (*func)(const CCTK_INT SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_C(CCTK_INT (*func)(const CCTK_INT SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestoreGroup_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex));
CCTK_INT AliasMoLRegisterSaveAndRestoreGroup_F(CCTK_INT (*func)(const CCTK_INT* SandRIndex))
{
  CCTK_INT aliased = MoLRegisterSaveAndRestoreGroup_C_Wrapper != NULL;
  if (!aliased)
  {
    MoLRegisterSaveAndRestoreGroup_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;
static CCTK_INT (*MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_ConvertFromPhysicalBoundary (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT MultiPatch_ConvertFromPhysicalBoundary (const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL multipatch_convertfromphysicalboundary_ (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL multipatch_convertfromphysicalboundary_ (const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_ConvertFromPhysicalBoundary has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_ConvertFromPhysicalBoundary(void);
CCTK_INT IsAliasedMultiPatch_ConvertFromPhysicalBoundary(void)
{
  return (MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_ConvertFromPhysicalBoundary_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 const CCTK_REAL* physical_min ,
 const CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 const CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_ConvertFromPhysicalBoundary_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_ConvertFromPhysicalBoundary_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetBbox_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox) = NULL;
static CCTK_INT (*MultiPatch_GetBbox_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetBbox (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox);
CCTK_INT MultiPatch_GetBbox (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBbox_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBbox has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBbox_C_Wrapper)(cctkGH , size , bbox);
  return (retval);
}

CCTK_INT CCTK_FCALL multipatch_getbbox_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox);
CCTK_INT CCTK_FCALL multipatch_getbbox_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBbox_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBbox has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBbox_F_Wrapper)(cctkGH , size , bbox);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetBbox(void);
CCTK_INT IsAliasedMultiPatch_GetBbox(void)
{
  return (MultiPatch_GetBbox_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetBbox_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox));
CCTK_INT AliasMultiPatch_GetBbox_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT size ,
 CCTK_INT* bbox))
{
  CCTK_INT aliased = MultiPatch_GetBbox_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBbox_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetBbox_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox));
CCTK_INT AliasMultiPatch_GetBbox_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* size ,
 CCTK_INT* bbox))
{
  CCTK_INT aliased = MultiPatch_GetBbox_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBbox_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetBoundarySpecification_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;
static CCTK_INT (*MultiPatch_GetBoundarySpecification_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetBoundarySpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT MultiPatch_GetBoundarySpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBoundarySpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBoundarySpecification_C_Wrapper)(map , size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

CCTK_INT CCTK_FCALL multipatch_getboundaryspecification_ (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout);
CCTK_INT CCTK_FCALL multipatch_getboundaryspecification_ (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout)
{
  CCTK_INT retval;

  if (!MultiPatch_GetBoundarySpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetBoundarySpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetBoundarySpecification_F_Wrapper)(map , size , nboundaryzones , is_internal , is_staggered , shiftout);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetBoundarySpecification(void);
CCTK_INT IsAliasedMultiPatch_GetBoundarySpecification(void)
{
  return (MultiPatch_GetBoundarySpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasMultiPatch_GetBoundarySpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = MultiPatch_GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBoundarySpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout));
CCTK_INT AliasMultiPatch_GetBoundarySpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_INT* nboundaryzones ,
 CCTK_INT* is_internal ,
 CCTK_INT* is_staggered ,
 CCTK_INT* shiftout))
{
  CCTK_INT aliased = MultiPatch_GetBoundarySpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetBoundarySpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetDomainSpecification_C_Wrapper) (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;
static CCTK_INT (*MultiPatch_GetDomainSpecification_F_Wrapper) (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetDomainSpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT MultiPatch_GetDomainSpecification (const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_GetDomainSpecification_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetDomainSpecification_C_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

CCTK_INT CCTK_FCALL multipatch_getdomainspecification_ (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing);
CCTK_INT CCTK_FCALL multipatch_getdomainspecification_ (const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing)
{
  CCTK_INT retval;

  if (!MultiPatch_GetDomainSpecification_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetDomainSpecification has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetDomainSpecification_F_Wrapper)(map , size , physical_min , physical_max , interior_min , interior_max , exterior_min , exterior_max , spacing);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetDomainSpecification(void);
CCTK_INT IsAliasedMultiPatch_GetDomainSpecification(void)
{
  return (MultiPatch_GetDomainSpecification_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_GetDomainSpecification_C(CCTK_INT (*func)(const CCTK_INT map ,
 const CCTK_INT size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetDomainSpecification_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing));
CCTK_INT AliasMultiPatch_GetDomainSpecification_F(CCTK_INT (*func)(const CCTK_INT* map ,
 const CCTK_INT* size ,
 CCTK_REAL* physical_min ,
 CCTK_REAL* physical_max ,
 CCTK_REAL* interior_min ,
 CCTK_REAL* interior_max ,
 CCTK_REAL* exterior_min ,
 CCTK_REAL* exterior_max ,
 CCTK_REAL* spacing))
{
  CCTK_INT aliased = MultiPatch_GetDomainSpecification_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetDomainSpecification_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*MultiPatch_GetMap_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*MultiPatch_GetMap_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT MultiPatch_GetMap (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT MultiPatch_GetMap (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMap_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMap has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetMap_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL multipatch_getmap_ (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL multipatch_getmap_ (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!MultiPatch_GetMap_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function MultiPatch_GetMap has not been provided by any active thorn.");
  }

  retval = (*MultiPatch_GetMap_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedMultiPatch_GetMap(void);
CCTK_INT IsAliasedMultiPatch_GetMap(void)
{
  return (MultiPatch_GetMap_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasMultiPatch_GetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasMultiPatch_GetMap_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMap_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasMultiPatch_GetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasMultiPatch_GetMap_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = MultiPatch_GetMap_C_Wrapper != NULL;
  if (!aliased)
  {
    MultiPatch_GetMap_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*NewRad_Apply_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower) = NULL;
static CCTK_INT (*NewRad_Apply_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT NewRad_Apply (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower);
CCTK_INT NewRad_Apply (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower)
{
  CCTK_INT retval;

  if (!NewRad_Apply_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function NewRad_Apply has not been provided by any active thorn.");
  }

  retval = (*NewRad_Apply_C_Wrapper)(cctkGH , var , rhs , var0 , v0 , radpower);
  return (retval);
}

CCTK_INT CCTK_FCALL newrad_apply_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower);
CCTK_INT CCTK_FCALL newrad_apply_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower)
{
  CCTK_INT retval;

  if (!NewRad_Apply_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function NewRad_Apply has not been provided by any active thorn.");
  }

  retval = (*NewRad_Apply_F_Wrapper)(cctkGH , var , rhs , var0 , v0 , radpower);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedNewRad_Apply(void);
CCTK_INT IsAliasedNewRad_Apply(void)
{
  return (NewRad_Apply_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasNewRad_Apply_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower));
CCTK_INT AliasNewRad_Apply_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL var0 ,
 const CCTK_REAL v0 ,
 const CCTK_INT radpower))
{
  CCTK_INT aliased = NewRad_Apply_C_Wrapper != NULL;
  if (!aliased)
  {
    NewRad_Apply_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasNewRad_Apply_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower));
CCTK_INT AliasNewRad_Apply_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_REAL* var ,
 CCTK_REAL* rhs ,
 const CCTK_REAL* var0 ,
 const CCTK_REAL* v0 ,
 const CCTK_INT* radpower))
{
  CCTK_INT aliased = NewRad_Apply_C_Wrapper != NULL;
  if (!aliased)
  {
    NewRad_Apply_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static void (*PhysToConfInPlace_C_Wrapper) (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;
static void (*PhysToConfInPlace_F_Wrapper) (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

void PhysToConfInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void PhysToConfInPlace (const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!PhysToConfInPlace_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PhysToConfInPlace has not been provided by any active thorn.");
  }

  (*PhysToConfInPlace_C_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

void CCTK_FCALL phystoconfinplace_ (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz);
void CCTK_FCALL phystoconfinplace_ (const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz)
{
  if (!PhysToConfInPlace_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function PhysToConfInPlace has not been provided by any active thorn.");
  }

  (*PhysToConfInPlace_F_Wrapper)(nx , ny , nz , psi , gxx , gxy , gxz , gyy , gyz , gzz);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedPhysToConfInPlace(void);
CCTK_INT IsAliasedPhysToConfInPlace(void)
{
  return (PhysToConfInPlace_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasPhysToConfInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasPhysToConfInPlace_C(void (*func)(const CCTK_INT nx ,
 const CCTK_INT ny ,
 const CCTK_INT nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = PhysToConfInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    PhysToConfInPlace_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasPhysToConfInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz));
CCTK_INT AliasPhysToConfInPlace_F(void (*func)(const CCTK_INT* nx ,
 const CCTK_INT* ny ,
 const CCTK_INT* nz ,
 const CCTK_REAL* psi ,
 CCTK_REAL* gxx ,
 CCTK_REAL* gxy ,
 CCTK_REAL* gxz ,
 CCTK_REAL* gyy ,
 CCTK_REAL* gyz ,
 CCTK_REAL* gzz))
{
  CCTK_INT aliased = PhysToConfInPlace_C_Wrapper != NULL;
  if (!aliased)
  {
    PhysToConfInPlace_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryHandleOfName_C_Wrapper) (CCTK_STRING sym_name) = NULL;
static CCTK_INT (*SymmetryHandleOfName_F_Wrapper) (CCTK_STRING sym_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryHandleOfName (CCTK_STRING sym_name);
CCTK_INT SymmetryHandleOfName (CCTK_STRING sym_name)
{
  CCTK_INT retval;

  if (!SymmetryHandleOfName_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryHandleOfName has not been provided by any active thorn.");
  }

  retval = (*SymmetryHandleOfName_C_Wrapper)(sym_name);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryhandleofname_ (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL symmetryhandleofname_ (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryHandleOfName_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryHandleOfName has not been provided by any active thorn.");
  }

  retval = (*SymmetryHandleOfName_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryHandleOfName(void);
CCTK_INT IsAliasedSymmetryHandleOfName(void)
{
  return (SymmetryHandleOfName_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryHandleOfName_C(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryHandleOfName_C(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryHandleOfName_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryHandleOfName_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryHandleOfName_F(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryHandleOfName_F(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryHandleOfName_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryHandleOfName_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryInterpolate_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;
static CCTK_INT (*SymmetryInterpolate_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT SymmetryInterpolate (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!SymmetryInterpolate_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolate has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolate_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryinterpolate_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays);
CCTK_INT CCTK_FCALL symmetryinterpolate_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays)
{
  CCTK_INT retval;

  if (!SymmetryInterpolate_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolate has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolate_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryInterpolate(void);
CCTK_INT IsAliasedSymmetryInterpolate(void)
{
  return (SymmetryInterpolate_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasSymmetryInterpolate_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = SymmetryInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolate_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays));
CCTK_INT AliasSymmetryInterpolate_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays))
{
  CCTK_INT aliased = SymmetryInterpolate_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolate_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryInterpolateFaces_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces) = NULL;
static CCTK_INT (*SymmetryInterpolateFaces_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryInterpolateFaces (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces);
CCTK_INT SymmetryInterpolateFaces (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)
{
  CCTK_INT retval;

  if (!SymmetryInterpolateFaces_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolateFaces has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolateFaces_C_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays , faces);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryinterpolatefaces_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces);
CCTK_INT CCTK_FCALL symmetryinterpolatefaces_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)
{
  CCTK_INT retval;

  if (!SymmetryInterpolateFaces_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryInterpolateFaces has not been provided by any active thorn.");
  }

  retval = (*SymmetryInterpolateFaces_F_Wrapper)(cctkGH , N_dims , local_interp_handle , param_table_handle , coord_system_handle , N_interp_points , interp_coords_type , interp_coords , N_input_arrays , input_array_indices , N_output_arrays , output_array_types , output_arrays , faces);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryInterpolateFaces(void);
CCTK_INT IsAliasedSymmetryInterpolateFaces(void)
{
  return (SymmetryInterpolateFaces_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryInterpolateFaces_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces));
CCTK_INT AliasSymmetryInterpolateFaces_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces))
{
  CCTK_INT aliased = SymmetryInterpolateFaces_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolateFaces_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryInterpolateFaces_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces));
CCTK_INT AliasSymmetryInterpolateFaces_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces))
{
  CCTK_INT aliased = SymmetryInterpolateFaces_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryInterpolateFaces_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_POINTER_TO_CONST (*SymmetryNameOfHandle_C_Wrapper) (const CCTK_INT sym_handle) = NULL;
static CCTK_POINTER_TO_CONST (*SymmetryNameOfHandle_F_Wrapper) (const CCTK_INT* sym_handle) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_POINTER_TO_CONST SymmetryNameOfHandle (const CCTK_INT sym_handle);
CCTK_POINTER_TO_CONST SymmetryNameOfHandle (const CCTK_INT sym_handle)
{
  CCTK_POINTER_TO_CONST retval;

  if (!SymmetryNameOfHandle_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryNameOfHandle has not been provided by any active thorn.");
  }

  retval = (*SymmetryNameOfHandle_C_Wrapper)(sym_handle);
  return (retval);
}

CCTK_POINTER_TO_CONST CCTK_FCALL symmetrynameofhandle_ (const CCTK_INT* sym_handle);
CCTK_POINTER_TO_CONST CCTK_FCALL symmetrynameofhandle_ (const CCTK_INT* sym_handle)
{
  CCTK_POINTER_TO_CONST retval;

  if (!SymmetryNameOfHandle_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryNameOfHandle has not been provided by any active thorn.");
  }

  retval = (*SymmetryNameOfHandle_F_Wrapper)(sym_handle);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryNameOfHandle(void);
CCTK_INT IsAliasedSymmetryNameOfHandle(void)
{
  return (SymmetryNameOfHandle_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryNameOfHandle_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT sym_handle));
CCTK_INT AliasSymmetryNameOfHandle_C(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT sym_handle))
{
  CCTK_INT aliased = SymmetryNameOfHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryNameOfHandle_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryNameOfHandle_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT* sym_handle));
CCTK_INT AliasSymmetryNameOfHandle_F(CCTK_POINTER_TO_CONST (*func)(const CCTK_INT* sym_handle))
{
  CCTK_INT aliased = SymmetryNameOfHandle_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryNameOfHandle_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegister_C_Wrapper) (CCTK_STRING sym_name) = NULL;
static CCTK_INT (*SymmetryRegister_F_Wrapper) (CCTK_STRING sym_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegister (CCTK_STRING sym_name);
CCTK_INT SymmetryRegister (CCTK_STRING sym_name)
{
  CCTK_INT retval;

  if (!SymmetryRegister_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegister has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegister_C_Wrapper)(sym_name);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryregister_ (ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL symmetryregister_ (ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryRegister_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegister has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegister_F_Wrapper)(cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegister(void);
CCTK_INT IsAliasedSymmetryRegister(void)
{
  return (SymmetryRegister_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegister_C(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryRegister_C(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegister_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegister_F(CCTK_INT (*func)(CCTK_STRING sym_name));
CCTK_INT AliasSymmetryRegister_F(CCTK_INT (*func)(CCTK_STRING sym_name))
{
  CCTK_INT aliased = SymmetryRegister_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegister_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGI_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index) = NULL;
static CCTK_INT (*SymmetryRegisterGI_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGI (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index);
CCTK_INT SymmetryRegisterGI (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGI_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_index);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryregistergi_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index);
CCTK_INT CCTK_FCALL symmetryregistergi_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGI_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGI(void);
CCTK_INT IsAliasedSymmetryRegisterGI(void)
{
  return (SymmetryRegisterGI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGI_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index));
CCTK_INT AliasSymmetryRegisterGI_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT group_index))
{
  CCTK_INT aliased = SymmetryRegisterGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGI_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index));
CCTK_INT AliasSymmetryRegisterGI_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 const CCTK_INT* group_index))
{
  CCTK_INT aliased = SymmetryRegisterGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGN_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name) = NULL;
static CCTK_INT (*SymmetryRegisterGN_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGN (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name);
CCTK_INT SymmetryRegisterGN (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGN_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , group_name);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryregistergn_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL symmetryregistergn_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryRegisterGN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGN_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGN(void);
CCTK_INT IsAliasedSymmetryRegisterGN(void)
{
  return (SymmetryRegisterGN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGN_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryRegisterGN_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryRegisterGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGN_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryRegisterGN_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryRegisterGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGrid_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width) = NULL;
static CCTK_INT (*SymmetryRegisterGrid_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGrid (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width);
CCTK_INT SymmetryRegisterGrid (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGrid_C_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryregistergrid_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width);
CCTK_INT CCTK_FCALL symmetryregistergrid_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width)
{
  CCTK_INT retval;

  if (!SymmetryRegisterGrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGrid_F_Wrapper)(cctkGH , sym_handle , which_faces , symmetry_zone_width);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGrid(void);
CCTK_INT IsAliasedSymmetryRegisterGrid(void)
{
  return (SymmetryRegisterGrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGrid_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width));
CCTK_INT AliasSymmetryRegisterGrid_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width))
{
  CCTK_INT aliased = SymmetryRegisterGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGrid_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width));
CCTK_INT AliasSymmetryRegisterGrid_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 const CCTK_INT* which_faces ,
 const CCTK_INT* symmetry_zone_width))
{
  CCTK_INT aliased = SymmetryRegisterGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGrid_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryRegisterGridInterpolator_C_Wrapper) (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)) = NULL;
static CCTK_INT (*SymmetryRegisterGridInterpolator_F_Wrapper) (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryRegisterGridInterpolator (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces));
CCTK_INT SymmetryRegisterGridInterpolator (const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces))
{
  CCTK_INT retval;

  if (!SymmetryRegisterGridInterpolator_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGridInterpolator has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGridInterpolator_C_Wrapper)(cctkGH , sym_handle , symmetry_interpolate);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetryregistergridinterpolator_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces));
CCTK_INT CCTK_FCALL symmetryregistergridinterpolator_ (const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces))
{
  CCTK_INT retval;

  if (!SymmetryRegisterGridInterpolator_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryRegisterGridInterpolator has not been provided by any active thorn.");
  }

  retval = (*SymmetryRegisterGridInterpolator_F_Wrapper)(cctkGH , sym_handle , symmetry_interpolate);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryRegisterGridInterpolator(void);
CCTK_INT IsAliasedSymmetryRegisterGridInterpolator(void)
{
  return (SymmetryRegisterGridInterpolator_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryRegisterGridInterpolator_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)));
CCTK_INT AliasSymmetryRegisterGridInterpolator_C(CCTK_INT (*func)(const CCTK_POINTER cctkGH ,
 const CCTK_INT sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT N_dims ,
 const CCTK_INT local_interp_handle ,
 const CCTK_INT param_table_handle ,
 const CCTK_INT coord_system_handle ,
 const CCTK_INT N_interp_points ,
 const CCTK_INT interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT faces)))
{
  CCTK_INT aliased = SymmetryRegisterGridInterpolator_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGridInterpolator_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryRegisterGridInterpolator_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)));
CCTK_INT AliasSymmetryRegisterGridInterpolator_F(CCTK_INT (*func)(const CCTK_POINTER* cctkGH ,
 const CCTK_INT* sym_handle ,
 CCTK_INT (*const symmetry_interpolate)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* N_dims ,
 const CCTK_INT* local_interp_handle ,
 const CCTK_INT* param_table_handle ,
 const CCTK_INT* coord_system_handle ,
 const CCTK_INT* N_interp_points ,
 const CCTK_INT* interp_coords_type ,
 const CCTK_POINTER_TO_CONST* interp_coords ,
 const CCTK_INT* N_input_arrays ,
 const CCTK_INT* input_array_indices ,
 const CCTK_INT* N_output_arrays ,
 const CCTK_INT* output_array_types ,
 const CCTK_POINTER* output_arrays ,
 const CCTK_INT* faces)))
{
  CCTK_INT aliased = SymmetryRegisterGridInterpolator_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryRegisterGridInterpolator_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGI_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index) = NULL;
static CCTK_INT (*SymmetryTableHandleForGI_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index);
CCTK_INT SymmetryTableHandleForGI (const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGI_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGI_C_Wrapper)(cctkGH , group_index);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetrytablehandleforgi_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index);
CCTK_INT CCTK_FCALL symmetrytablehandleforgi_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGI_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGI has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGI_F_Wrapper)(cctkGH , group_index);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGI(void);
CCTK_INT IsAliasedSymmetryTableHandleForGI(void)
{
  return (SymmetryTableHandleForGI_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index));
CCTK_INT AliasSymmetryTableHandleForGI_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 const CCTK_INT group_index))
{
  CCTK_INT aliased = SymmetryTableHandleForGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGI_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index));
CCTK_INT AliasSymmetryTableHandleForGI_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 const CCTK_INT* group_index))
{
  CCTK_INT aliased = SymmetryTableHandleForGI_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGI_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGN_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name) = NULL;
static CCTK_INT (*SymmetryTableHandleForGN_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name);
CCTK_INT SymmetryTableHandleForGN (const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGN_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGN_C_Wrapper)(cctkGH , group_name);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetrytablehandleforgn_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG);
CCTK_INT CCTK_FCALL symmetrytablehandleforgn_ (const CCTK_POINTER_TO_CONST* cctkGH ,
 ONE_FORTSTRING_ARG)
{
  CCTK_INT retval;

ONE_FORTSTRING_CREATE(cctki_string1)

  if (!SymmetryTableHandleForGN_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGN has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGN_F_Wrapper)(cctkGH , cctki_string1);
  free(cctki_string1);
  return retval;
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGN(void);
CCTK_INT IsAliasedSymmetryTableHandleForGN(void)
{
  return (SymmetryTableHandleForGN_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryTableHandleForGN_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryTableHandleForGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGN_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name));
CCTK_INT AliasSymmetryTableHandleForGN_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH ,
 CCTK_STRING group_name))
{
  CCTK_INT aliased = SymmetryTableHandleForGN_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGN_F_Wrapper = func;
  }
  return aliased;
}

/*
 * The function pointers to be set
 */

static CCTK_INT (*SymmetryTableHandleForGrid_C_Wrapper) (const CCTK_POINTER_TO_CONST cctkGH) = NULL;
static CCTK_INT (*SymmetryTableHandleForGrid_F_Wrapper) (const CCTK_POINTER_TO_CONST* cctkGH) = NULL;

/*
 * The functions that are linked to by the USEing thorn
 */

CCTK_INT SymmetryTableHandleForGrid (const CCTK_POINTER_TO_CONST cctkGH);
CCTK_INT SymmetryTableHandleForGrid (const CCTK_POINTER_TO_CONST cctkGH)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGrid_C_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGrid_C_Wrapper)(cctkGH);
  return (retval);
}

CCTK_INT CCTK_FCALL symmetrytablehandleforgrid_ (const CCTK_POINTER_TO_CONST* cctkGH);
CCTK_INT CCTK_FCALL symmetrytablehandleforgrid_ (const CCTK_POINTER_TO_CONST* cctkGH)
{
  CCTK_INT retval;

  if (!SymmetryTableHandleForGrid_F_Wrapper)
  {
    CCTK_Warn(0, __LINE__, __FILE__, "Bindings","The function SymmetryTableHandleForGrid has not been provided by any active thorn.");
  }

  retval = (*SymmetryTableHandleForGrid_F_Wrapper)(cctkGH);
  return (retval);
}

/*
 * The functions that check if it has been PROVIDEd
 */

CCTK_INT IsAliasedSymmetryTableHandleForGrid(void);
CCTK_INT IsAliasedSymmetryTableHandleForGrid(void)
{
  return (SymmetryTableHandleForGrid_C_Wrapper != NULL);
}

/*
 * The functions that overload the above function pointers.
 */

CCTK_INT AliasSymmetryTableHandleForGrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH));
CCTK_INT AliasSymmetryTableHandleForGrid_C(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST cctkGH))
{
  CCTK_INT aliased = SymmetryTableHandleForGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGrid_C_Wrapper = func;
  }
  return aliased;
}
CCTK_INT AliasSymmetryTableHandleForGrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH));
CCTK_INT AliasSymmetryTableHandleForGrid_F(CCTK_INT (*func)(const CCTK_POINTER_TO_CONST* cctkGH))
{
  CCTK_INT aliased = SymmetryTableHandleForGrid_C_Wrapper != NULL;
  if (!aliased)
  {
    SymmetryTableHandleForGrid_F_Wrapper = func;
  }
  return aliased;
}
